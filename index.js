'use strict';const _=exports,{clone}=require("mediary");_.clone=clone,_.nil=void 0,_.isArray=Array.isArray,_.is=(a,b)=>typeof a===b,_.isNil=a=>a==_.nil,_.notNil=a=>a!=_.nil,_.isObject=a=>_.notNil(a)&&_.is(a,"object"),_.isEqual=(c,a)=>[c,a].every(_.isObject)?Object.is(c,a):c===a,_.isFalse=a=>_.isEqual(a,!1),_.isFalsy=a=>_.isNil(a)||_.isFalse(a),_.complement=a=>(...b)=>_.isFalsy(a(...b)),_.isTruthy=_.complement(_.isFalsy),_.isZero=a=>0===a,_.isString=a=>_.is(a,"string"),_.isNumber=a=>_.is(a,"number"),_.isBoolean=a=>_.is(a,"boolean"),_.isUndefined=a=>_.is(a,"undefined"),_.isNull=a=>null===a,_.isPlainObject=a=>"[object Object]"===Object.prototype.toString.call(a),_.not=_.isFalsy,_.partial=(a,...b)=>(...c)=>a(...[...b,...c]),_.partialRight=(a,...b)=>(...c)=>a(...[...c,...b]),_.deepClone=a=>_.isArray(a)?[...a].map(_.deepClone):_.isObject(a)?Object.entries({...a}).reduce((b,[a,c])=>(b[a]=_.deepClone(c),b),{}):a,["fill","push","reverse","unshift","splice"].forEach((a,b)=>_[a]=(c,...d)=>(b=clone(c)||[],[][a].apply(b,d),b)),["concat","join","slice","every","filter","find","findIndex","forEach","map","reduce","reduceRight","some"].forEach(a=>_[a]=(b,...c)=>[][a].apply(clone(b)||[],c.map(clone))),["entries","keys","values"].forEach(a=>_[a]=b=>_.isArray(b)?[...[][a].apply(b||[])]:Object[a](b)),["pop","shift"].forEach(a=>_[a]=b=>clone(b)[a]()),["includes","indexOf","lastIndexOf"].forEach(a=>_[a]=(b,c)=>b[a](c)),_.sort=(a,b)=>clone(a).sort(_.every(a,_.isNumber)?(c,a)=>c-a:b),_.and=(...a)=>_.reduce(a,(c,a)=>_.isFalsy(c)?c:a),_.or=(...a)=>_.reduce(a,(c,a)=>_.isFalsy(c)?a:c),_.isEqiv=(c,a)=>{if([c,a].every(_.isObject)){const b=_.keys(c);if(b.length!=_.keys(a).length)return!1;for(;b.length;){let d=b.pop();if(c[d]!==a[d])return!1}return!0}return c==a},_.pipe=(a,...b)=>(...c)=>_.reduce(b,(a,b)=>b(a),a(...c)),_.compose=(...a)=>(a=>(...b)=>_.pipe(...a)(...b))(_.reverse([...a])),_.isEmpty=a=>_.isArray(a)||_.isString(a)?!a.length:_.isObject(a)?!Object.keys(a).length:_.isNil(a),_.castPath=a=>{if(_.isArray(a))return[...a];const b=(""+a).split(""),c=[];let d="",e=0;const f=a=>(c.push(/^[0-9]+$/.test(a)?+a:a),d="");for(;e<b.length;)if([".","[","]"].includes(b[e])){if(0==e++)continue;"]"!==b[e-2]&&f(d)}else if(["'","\""].includes(b[e])){for(let a=b[e++];b[e]!==a;)"\\"===b[e]&&(d+=b[e++]),d+=b[e++];e++}else d+=b[e++];return d.length&&f(d),c},_.get=(a,b,c)=>_.pipe(_.castPath,_.partialRight(_.reduce,(b,a)=>_.isObject(b)&&b[a]||_.nil,a))(b)||c,_.has=(a,b)=>_.pipe(_.isNil,_.not)(_.get(a,b)),_.walkPath=(a,b,d,c=!1)=>{const e=_.castPath(b),f=null==a?_.isNumber(e[0])?[]:{}:c?a:clone(a)||{};for(let g=f;e.length;){let a=e.shift(),b=e[0];d(g,a,b),null!=b&&(g=g[a])}return f},_.assoc=(a,b,d,c=!1)=>_.walkPath(a,b,(a,b,c)=>_.isNil(c)?a[b]=d:a[b]=clone(_.isNil(a[b])&&_.isNumber(c)?[]:a[b])||{},c),_.dissoc=(a,b,c=!1)=>_.walkPath(a,b,(a,b,c)=>_.isNil(c)?_.isArray(a)?a.splice(_.isNil(c),a.length):delete a[b]:a[b]=clone(a[b])||{},c),_.set=_.partialRight(_.assoc,!0),_.drop=_.partialRight(_.dissoc,!0),_.assign=Object.assign,_.merge=(...a)=>_.reduce(a,(b,a)=>(_.forEach(_.entries(a),([a,c])=>{_.isObject(c)?b[a]=_.merge(b[a]||(_.isArray(c)?[]:{}),c):_.notNil(c)&&(b[a]=c)}),b));